/*
 * This file was automatically generated by sel-utils and
 * released under the MIT License.
 * 
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 * Generated from https://github.com/sel-project/sel-utils/blob/master/xml/protocol/raknet8.xml
 */
using System.Text;

namespace sul.Protocol.Raknet8.Types
{

    public class Address : sul.Utils.Stream
    {

        public byte type;
        public uint ipv4;
        public byte[] ipv6;
        public byte[] unknown3;
        public ushort port;

        public Address() : this(0, 0, new byte[16], new byte[10], 0) {}

        public Address(byte type, uint ipv4, byte[] ipv6, byte[] unknown3, ushort port)
        {
            this.type = type;
            this.ipv4 = ipv4;
            this.ipv6 = ipv6;
            this.unknown3 = unknown3;
            this.port = port;
        }

        protected override void EncodeImpl(sul.Utils.Buffer _buffer)
        {
            _buffer.WriteUbyte(type);
            if(type==4){ _buffer.WriteBigEndianUint(ipv4); }
            if(type==6){ foreach (byte ipv6Child in ipv6){ _buffer.WriteUbyte(ipv6Child); } }
            if(type==6){ foreach (byte unknown3Child in unknown3){ _buffer.WriteUbyte(unknown3Child); } }
            _buffer.WriteBigEndianUshort(port);
        }

        protected override void DecodeImpl(sul.Utils.Buffer _buffer)
        {
            //_buffer.ReadUbyte()
            //if(type==4){ _buffer.ReadBigEndianUint() }
            //if(type==6){ ipv6.DecodeBody(_buffer); }
            //if(type==6){ unknown3.DecodeBody(_buffer); }
            //_buffer.ReadBigEndianUshort()
        }

    }

    public class Acknowledge : sul.Utils.Stream
    {

        public bool unique;
        public int first;
        public int last;

        public Acknowledge() : this(false, 0, 0) {}

        public Acknowledge(bool unique, int first, int last)
        {
            this.unique = unique;
            this.first = first;
            this.last = last;
        }

        protected override void EncodeImpl(sul.Utils.Buffer _buffer)
        {
            _buffer.WriteBool(unique);
            _buffer.WriteLittleEndianTriad(first);
            if(unique==false){ _buffer.WriteLittleEndianTriad(last); }
        }

        protected override void DecodeImpl(sul.Utils.Buffer _buffer)
        {
            //_buffer.ReadBool()
            //_buffer.ReadLittleEndianTriad()
            //if(unique==false){ _buffer.ReadLittleEndianTriad() }
        }

    }

    public class Encapsulation : sul.Utils.Stream
    {

        public byte info;
        public ushort length;
        public int messageIndex;
        public int orderIndex;
        public byte orderChannel;
        public Split split;
        public byte[] payload;

        public Encapsulation() : this(0, 0, 0, 0, 0, new Split(), new byte[]{}) {}

        public Encapsulation(byte info, ushort length, int messageIndex, int orderIndex, byte orderChannel, Split split, byte[] payload)
        {
            this.info = info;
            this.length = length;
            this.messageIndex = messageIndex;
            this.orderIndex = orderIndex;
            this.orderChannel = orderChannel;
            this.split = split;
            this.payload = payload;
        }

        protected override void EncodeImpl(sul.Utils.Buffer _buffer)
        {
            _buffer.WriteUbyte(info);
            _buffer.WriteBigEndianUshort(length);
            if((info&0x7F)>=64){ _buffer.WriteLittleEndianTriad(messageIndex); }
            if((info&0x7F)>=96){ _buffer.WriteLittleEndianTriad(orderIndex); }
            if((info&0x7F)>=96){ _buffer.WriteUbyte(orderChannel); }
            if((info&0x10)!=0){ split.EncodeBody(_buffer); }
            _buffer.WriteBytes(payload);
        }

        protected override void DecodeImpl(sul.Utils.Buffer _buffer)
        {
            //_buffer.ReadUbyte()
            //_buffer.ReadBigEndianUshort()
            //if((info&0x7F)>=64){ _buffer.ReadLittleEndianTriad() }
            //if((info&0x7F)>=96){ _buffer.ReadLittleEndianTriad() }
            //if((info&0x7F)>=96){ _buffer.ReadUbyte() }
            //if((info&0x10)!=0){ split.DecodeBody(_buffer); }
            //_buffer.ReadBytes()
        }

    }

    public class Split : sul.Utils.Stream
    {

        public uint count;
        public ushort id;
        public uint order;

        public Split() : this(0, 0, 0) {}

        public Split(uint count, ushort id, uint order)
        {
            this.count = count;
            this.id = id;
            this.order = order;
        }

        protected override void EncodeImpl(sul.Utils.Buffer _buffer)
        {
            _buffer.WriteBigEndianUint(count);
            _buffer.WriteBigEndianUshort(id);
            _buffer.WriteBigEndianUint(order);
        }

        protected override void DecodeImpl(sul.Utils.Buffer _buffer)
        {
            //_buffer.ReadBigEndianUint()
            //_buffer.ReadBigEndianUshort()
            //_buffer.ReadBigEndianUint()
        }

    }

}
