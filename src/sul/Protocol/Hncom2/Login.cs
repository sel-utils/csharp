/*
 * This file was automatically generated by sel-utils and
 * released under the MIT License.
 * 
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 * Generated from https://github.com/sel-project/sel-utils/blob/master/xml/protocol/hncom2.xml
 */
using Types = sul.Hncom2.Types;

using Utils.Buffer;
using Utils.Packet;

namespace sul.Hncom2
{

    public class ConnectionRequest : Packet
    {

        public const byte Id = 3;

        public const bool Clientbound = false;
        public const bool Serverbound = true;

        public uint protocol;
        public string password;
        public string name;
        public bool main = true;

        public ConnectionRequest() {}

        public ConnectionRequest(uint protocol, string password, string name, bool main)
        {
            this.protocol = protocol;
            this.password = password;
            this.name = name;
            this.main = main;
        }

        public override int GetId()
        {
            return Id;
        }

        protected override void EncodeId(Buffer _buffer)
        {
            _buffer.WriteUbyte(Id);
        }

        protected override void DecodeId(Buffer _buffer)
        {
            _buffer.ReadUbyte();
        }

        protected override void EncodeImpl(Buffer _buffer)
        {
            _buffer.WriteVaruint(protocol);
            _buffer.WriteVaruint(Encoding.UTF8.GetByteCount(password)); _buffer.WriteString(password);
            _buffer.WriteVaruint(Encoding.UTF8.GetByteCount(name)); _buffer.WriteString(name);
            _buffer.WriteBool(main);
        }

        protected override void DecodeImpl(Buffer _buffer)
        {




        }

        public static ConnectionRequest FromBuffer(byte[] buffer)
        {
            var ret = new ConnectionRequest();
            ret.decode(buffer);
            return ret;
        }

    }

    public class ConnectionResponse : Packet
    {

        public const byte Id = 4;

        public const bool Clientbound = true;
        public const bool Serverbound = false;

        // status
        public const byte Ok = 0;
        public const byte OutdatedHub = 1;
        public const byte OutdatedNode = 2;
        public const byte PasswordRequired = 3;
        public const byte WrongPassword = 4;
        public const byte InvalidNameLength = 5;
        public const byte InvalidNameCharacters = 6;
        public const byte NameAlreadyUsed = 7;
        public const byte NameReserved = 8;

        public byte status;
        public uint protocol;

        public ConnectionResponse() {}

        public ConnectionResponse(byte status, uint protocol)
        {
            this.status = status;
            this.protocol = protocol;
        }

        public override int GetId()
        {
            return Id;
        }

        protected override void EncodeId(Buffer _buffer)
        {
            _buffer.WriteUbyte(Id);
        }

        protected override void DecodeId(Buffer _buffer)
        {
            _buffer.ReadUbyte();
        }

        protected override void EncodeImpl(Buffer _buffer)
        {
            _buffer.WriteUbyte(status);
            if(status==1||status==2){ _buffer.WriteVaruint(protocol); }
        }

        protected override void DecodeImpl(Buffer _buffer)
        {

            if(status==1||status==2){  }
        }

        public static ConnectionResponse FromBuffer(byte[] buffer)
        {
            var ret = new ConnectionResponse();
            ret.decode(buffer);
            return ret;
        }

    }

    public class HubInfo : Packet
    {

        public const byte Id = 5;

        public const bool Clientbound = true;
        public const bool Serverbound = false;

        // max
        public const int Unlimited = -1;

        public ulong time;
        public ulong serverId;
        public ulong reservedUuids;
        public string displayName;
        public Types.GameInfo[] gamesInfo;
        public uint online;
        public int max;
        public string language;
        public string[] acceptedLanguages;
        public string additionalJson;

        public HubInfo() {}

        public HubInfo(ulong time, ulong serverId, ulong reservedUuids, string displayName, Types.GameInfo[] gamesInfo, uint online, int max, string language, string[] acceptedLanguages, string additionalJson)
        {
            this.time = time;
            this.serverId = serverId;
            this.reservedUuids = reservedUuids;
            this.displayName = displayName;
            this.gamesInfo = gamesInfo;
            this.online = online;
            this.max = max;
            this.language = language;
            this.acceptedLanguages = acceptedLanguages;
            this.additionalJson = additionalJson;
        }

        public override int GetId()
        {
            return Id;
        }

        protected override void EncodeId(Buffer _buffer)
        {
            _buffer.WriteUbyte(Id);
        }

        protected override void DecodeId(Buffer _buffer)
        {
            _buffer.ReadUbyte();
        }

        protected override void EncodeImpl(Buffer _buffer)
        {
            _buffer.WriteVarulong(time);
            _buffer.WriteVarulong(serverId);
            _buffer.WriteVarulong(reservedUuids);
            _buffer.WriteVaruint(Encoding.UTF8.GetByteCount(displayName)); _buffer.WriteString(displayName);
            _buffer.WriteVaruint(gamesInfo.Length); foreach(Types.GameInfo gamesInfoChild in gamesInfo){ gamesInfoChild.EncodeBody(_buffer); }
            _buffer.WriteVaruint(online);
            _buffer.WriteVarint(max);
            _buffer.WriteVaruint(Encoding.UTF8.GetByteCount(language)); _buffer.WriteString(language);
            _buffer.WriteVaruint(acceptedLanguages.Length); foreach(string acceptedLanguagesChild in acceptedLanguages){ _buffer.WriteVaruint(Encoding.UTF8.GetByteCount(acceptedLanguagesChild)); _buffer.WriteString(acceptedLanguagesChild); }
            _buffer.WriteVaruint(Encoding.UTF8.GetByteCount(additionalJson)); _buffer.WriteString(additionalJson);
        }

        protected override void DecodeImpl(Buffer _buffer)
        {










        }

        public static HubInfo FromBuffer(byte[] buffer)
        {
            var ret = new HubInfo();
            ret.decode(buffer);
            return ret;
        }

    }

    public class NodeInfo : Packet
    {

        public const byte Id = 6;

        public const bool Clientbound = false;
        public const bool Serverbound = true;

        // max
        public const uint Unlimited = 0;

        public ulong time;
        public uint max;
        public Types.Game[] acceptedGames;
        public Types.Plugin[] plugins;
        public string additionalJson;

        public NodeInfo() {}

        public NodeInfo(ulong time, uint max, Types.Game[] acceptedGames, Types.Plugin[] plugins, string additionalJson)
        {
            this.time = time;
            this.max = max;
            this.acceptedGames = acceptedGames;
            this.plugins = plugins;
            this.additionalJson = additionalJson;
        }

        public override int GetId()
        {
            return Id;
        }

        protected override void EncodeId(Buffer _buffer)
        {
            _buffer.WriteUbyte(Id);
        }

        protected override void DecodeId(Buffer _buffer)
        {
            _buffer.ReadUbyte();
        }

        protected override void EncodeImpl(Buffer _buffer)
        {
            _buffer.WriteVarulong(time);
            _buffer.WriteVaruint(max);
            _buffer.WriteVaruint(acceptedGames.Length); foreach(Types.Game acceptedGamesChild in acceptedGames){ acceptedGamesChild.EncodeBody(_buffer); }
            _buffer.WriteVaruint(plugins.Length); foreach(Types.Plugin pluginsChild in plugins){ pluginsChild.EncodeBody(_buffer); }
            _buffer.WriteVaruint(Encoding.UTF8.GetByteCount(additionalJson)); _buffer.WriteString(additionalJson);
        }

        protected override void DecodeImpl(Buffer _buffer)
        {





        }

        public static NodeInfo FromBuffer(byte[] buffer)
        {
            var ret = new NodeInfo();
            ret.decode(buffer);
            return ret;
        }

    }

}
