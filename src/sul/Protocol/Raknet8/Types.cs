/*
 * This file was automatically generated by sel-utils and
 * released under the MIT License.
 * 
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 * Generated from https://github.com/sel-project/sel-utils/blob/master/xml/protocol/raknet8.xml
 */
using Utils.Buffer;
using Utils.LengthPrefixedType;
using Utils.Stream;

namespace sul.Raknet8.Types
{

    public class Address : Stream
    {

        public byte type;
        public uint ipv4;
        public byte[16] ipv6;
        public ushort port;

        public Address() {}

        public Address(byte type, uint ipv4, byte[16] ipv6, ushort port)
        {
            this.type = type;
            this.ipv4 = ipv4;
            this.ipv6 = ipv6;
            this.port = port;
        }

        protected override void EncodeImpl(Buffer buffer)
        {
            _buffer.WriteUbyte(type);
            if(type==4){ _buffer.WriteBigEndianUint(ipv4); }
            if(type==6){ foreach(byte ipv6Child in ipv6){ _buffer.WriteUbyte(ipv6Child); } }
            _buffer.WriteBigEndianUshort(port);
        }

        protected override void DecodeImpl(Buffer buffer)
        {

            if(type==4){  }
            if(type==6){  }

        }

    }

    public class Acknowledge : Stream
    {

        public bool unique;
        public int first;
        public int last;

        public Acknowledge() {}

        public Acknowledge(bool unique, int first, int last)
        {
            this.unique = unique;
            this.first = first;
            this.last = last;
        }

        protected override void EncodeImpl(Buffer buffer)
        {
            _buffer.WriteBool(unique);
            _buffer.WriteLittleEndianTriad(first);
            if(unique==false){ _buffer.WriteLittleEndianTriad(last); }
        }

        protected override void DecodeImpl(Buffer buffer)
        {


            if(unique==false){  }
        }

    }

    public class Encapsulation : Stream
    {

        public byte info;
        public ushort length;
        public int messageIndex;
        public int orderIndex;
        public byte orderChannel;
        public Types.Split split;
        public byte[] payload;

        public Encapsulation() {}

        public Encapsulation(byte info, ushort length, int messageIndex, int orderIndex, byte orderChannel, Types.Split split, byte[] payload)
        {
            this.info = info;
            this.length = length;
            this.messageIndex = messageIndex;
            this.orderIndex = orderIndex;
            this.orderChannel = orderChannel;
            this.split = split;
            this.payload = payload;
        }

        protected override void EncodeImpl(Buffer buffer)
        {
            _buffer.WriteUbyte(info);
            _buffer.WriteBigEndianUshort(length);
            if((info&0x7F)>=64){ _buffer.WriteLittleEndianTriad(messageIndex); }
            if((info&0x7F)>=96){ _buffer.WriteLittleEndianTriad(orderIndex); }
            if((info&0x7F)>=96){ _buffer.WriteUbyte(orderChannel); }
            if((info&0x10)!=0){ split.EncodeBody(_buffer); }
            _buffer.WriteBytes(payload);
        }

        protected override void DecodeImpl(Buffer buffer)
        {


            if((info&0x7F)>=64){  }
            if((info&0x7F)>=96){  }
            if((info&0x7F)>=96){  }
            if((info&0x10)!=0){  }

        }

    }

    public class Split : Stream
    {

        public uint count;
        public ushort id;
        public uint order;

        public Split() {}

        public Split(uint count, ushort id, uint order)
        {
            this.count = count;
            this.id = id;
            this.order = order;
        }

        protected override void EncodeImpl(Buffer buffer)
        {
            _buffer.WriteBigEndianUint(count);
            _buffer.WriteBigEndianUshort(id);
            _buffer.WriteBigEndianUint(order);
        }

        protected override void DecodeImpl(Buffer buffer)
        {



        }

    }

}
